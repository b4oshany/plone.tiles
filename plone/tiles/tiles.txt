==============
Creating tiles
==============

Tiles are a form of view component used to compose pages. Think of a tile as
a view describing one part of a page, that can be configured with some data
described by a schema and inserted into a layout via a dedicated GUI.

Like a browser view, a tile can be traversed to a published on its own. The
API in this package provides support for tiles being configured according to
a schema with data either passed on the query string (transient tiles) or
retrieved from annotations (persistent tiles). Note that there is no direct UI
support in this package, so the forms that allow users to construct and edit
tiles must lives elsewhere.

To use the package, you should first load its ZCML configuration.

    >>> configuration = """\
    ... <configure
    ...      xmlns="http://namespaces.zope.org/zope"
    ...      xmlns:plone="http://namespaces.plone.org/plone"
    ...      i18n_domain="plone.tiles.tests">
    ...     
    ...     <include package="zope.component" file="meta.zcml" />
    ...     
    ...     <include package="plone.tiles" file="meta.zcml" />
    ...     <include package="plone.tiles" />
    ... 
    ... </configure>
    ... """

    >>> from StringIO import StringIO
    >>> from zope.configuration import xmlconfig
    >>> xmlconfig.xmlconfig(StringIO(configuration))

A simple transient tile
-----------------------

A basic tile is a view that implements the `ITile` interface. The easiest way
to do this is to subclass the `Tile` class.

    >>> from plone.tiles import Tile
    >>> class SampleTile(Tile):
    ...
    ...     def __call__(self):
    ...         return "<b>My tile</b>"

The tile is a browser view, and has two special attributes that will be set
upon traversal by the `++tile++` namespace: `__name__`, the name of the
instance of the tile when it has been added to a layout, and `__type_name__`,
which will be set to the name of the view as registered.

    >>> from plone.tiles.interfaces import ITile
    >>> ITile.implementedBy(SampleTile)
    True
    
    >>> from zope.publisher.interfaces.browser import IBrowserView
    >>> IBrowserView.implementedBy(SampleTile)
    True
    
    >>> tile = SampleTile(None, None)
    >>> tile.__name__ is None
    True
    >>> tile.__type_name__ is None
    True
    
This tile is registered as a normal browser view, alongside a utility that
provides some information about the tile itself. Normally, this is done
using the `<plone:tile />` directive. Here's how to create one manually:

    >>> from plone.tiles.type import TileType
    >>> sample_tile_type = TileType(
    ...     name=u'sample.tile',
    ...     title=u"Sample tile",
    ...     description=u"A tile used for testing",
    ...     add_permission="dummy.Permission",
    ...     schema=None)

The name should match the view name and the name the utility is registered
under. The title and description may be used by the UI. The add permission
is the name of a permission that will be required to insert the tile. The
schema attribute may be used to indicate schema interface describing the
tile's configurable data - more on this below.

To register a tile in ZCML, we could do::

    <plone:tile
        name="sample.tile"
        title="Sample tile"
        description='A tile used for testing
        add_permission="dummy.Permission"
        class=".mytiles.SampleTile"
        for="*"
        permission="zope.Public"
        />

It is also possible to specify a `layer` or `template` like the `browser:page`
directive, as well as a `schema`.

We'll register the sample tile directly here, for later testing.

    >>> from zope.component import provideAdapter, provideUtility
    >>> from zope.interface import Interface
    >>> from plone.tiles.interfaces import IBasicTile

    >>> provideUtility(sample_tile_type, name=u'sample.tile')
    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u"sample.tile")

The tile traverser
------------------

Whilst tiles are publishable as a normal browser view, they will usually be
traversed to using the ++tile++ traversal namespace. This allows tiles to be
made aware of their name. The name is a unique ID saved with the layout and
encoded into the URL, and may be the basis for looking up tile data.

For example, a tile may be saved in a layout as a link like::

    <a rel="tile" href="./++tile++layout1-tile1/sample.tile" />

During rendering, the tile's context will be the current object (since that
is the context before the `++tile++` namespace). The tile name will be
`layout1-tile`.

Let's create a sample context, invoke the traversal namespace directly,
and verify how the tile is instantiated.

    >>> from zope.interface import implements

    >>> class IContext(Interface):
    ...     pass

    >>> class Context(object):
    ...     implements(IContext)
    
    >>> from zope.publisher.browser import TestRequest
    
    >>> context = Context()
    >>> request = TestRequest()

    >>> from zope.component import getMultiAdapter
    >>> from zope.traversing.interfaces import ITraversable

    >>> traversable = getMultiAdapter((context, request), ITraversable, name=u"tile")
    >>> tile = traversable.traverse(u'layout1-tile1', ['sample.tile'])

The tile will now be aware of its name and type:

    >>> isinstance(tile, SampleTile)
    True
    >>> tile.__parent__ is context
    True
    
    >>> tile.__name__
    u'layout1-tile1'
    >>> tile.__type_name__
    'sample.tile'

Transient tile data 
-------------------

Let us now consider how tiles may have data. In the simplest case, tile
data is passed on the query string, and described according to a schema.
A simple schema may look like:

    >>> import zope.schema
    >>> class ISampleTileData(Interface):
    ...     title = zope.schema.TextLine(title=u"Tile title")
    ...     css_class = zope.schema.ASCIILine(title=u"CSS class to apply")
    ...     count = zope.schema.Int(title=u"Number of things to show in the tile")

We would normally have listed this interface when registering this tile in
ZCML. We can simply update the utility here.

    >>> sample_tile_type.schema = ISampleTileData

Tile data is represented by a simple dictionary. For example:

    >>> data = {'title': u"My title", 'count': 5, 'css_class': 'foo'}

The idea is that a tile add form is built from the schema interface, and its
data saved to a dictionary.

For transient tiles, this data is then encoded into the tile query string. To
help with this, a utility function can be used to encode a dict to a query
string, applying Zope form marshalers according to the types described in
the schema:

    >>> from plone.tiles.data import encode
    >>> encode(data, ISampleTileData)
    'title=My+title&css_class=foo&count%3Along=5'

The `count%3Along=5` bit is the encoded version of `count:long=5`.

Note that not all field types may be saved. In particular, object, interface,
set or frozenset fields may not be saved, and will result in a KeyError.
Lengthy text fields may also be a problem. For these types of fields, look to
use persistent tiles instead.

Also, the conversion may not be perfect. For example, Zope's form marshalers
cannot distinguish between unicode and ascii fields. Therefore, there is a
corresponding decode() method that may be used to ensure that the values
match the schema:

    >>> marshaled = {'title': u"My tile", 'count': 5, 'css_class': u'foo'}

    >>> from plone.tiles.data import decode
    >>> decode(marshaled, ISampleTileData)
    {'count': 5, 'css_class': 'foo', 'title': u'My tile'}

When saved into a layout, the tile link would now look like::

    <a rel="tile" href="./++tile++layout1-tile1/sample.tile?title=My+title&count%3Along=5" />

Let's simulate traversal once more and see how the data is now available to
the tile instance:

    >>> context = Context()
    >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'css_class': u'foo'})

    >>> traversable = getMultiAdapter((context, request), ITraversable, name=u"tile")
    >>> tile = traversable.traverse(u'layout1-tile1', ['sample.tile'])
    >>> tile.data
    {'count': 5, 'css_class': 'foo', 'title': u'My title'}

Notice also how the data has been properly decoded according to the schema.

Persistent tiles
----------------

Of course, not all types of data can be placed in a query string. For more
substantial data require, you can use persistent tiles, which store data in
annotations.

First, we need to write up annotations support.

    >>> from zope.annotation.attribute import AttributeAnnotations
    >>> provideAdapter(AttributeAnnotations)

We also need a context that is annotatable.

    >>> from zope.annotation.interfaces import IAttributeAnnotatable
    >>> from zope.interface import alsoProvides
    >>> alsoProvides(context, IAttributeAnnotatable)

Now, let's create a persistent tile with a schema.

    >>> class IPersistentSampleData(Interface):
    ...     text = zope.schema.Text(title=u"Detailed text", missing_value=u"Missing!")

    >>> from plone.tiles import PersistentTile
    >>> class PersistentSampleTile(PersistentTile):
    ...
    ...     def __call__(self):
    ...         return u"<b>You said</b> %s" % self.data['text']

    >>> persistent_sample_tile_type = TileType(
    ...     name=u'sample.persistenttile',
    ...     title=u"Persistent sample tile",
    ...     description=u"A tile used for testing",
    ...     add_permission="dummy.Permission",
    ...     schema=IPersistentSampleData)
    
    >>> provideUtility(persistent_sample_tile_type, name=u'sample.persistenttile')
    >>> provideAdapter(PersistentSampleTile, (Interface, Interface), IBasicTile, name=u"sample.persistenttile")

We can now traverse to the tile as before. By default, there is no data, and
the field's missing value will be used.

    >>> traversable = getMultiAdapter((context, request), ITraversable, name=u"tile")
    >>> tile = traversable.traverse(u'layout1-tile2', ['sample.persistenttile'])
    >>> tile()
    u'<b>You said</b> Missing!'

We can write data to the context's annotations using an ITileDataManager:

    >>> from plone.tiles.interfaces import ITileDataManager
    >>> dm = getMultiAdapter((context, tile), ITileDataManager)
    >>> dm.set({'text': u"Hello!"})

This writes data to annotations:

    >>> sorted(dict(context.__annotations__).items()) # doctest: +ELLIPSIS
    [(u'plone.tiles.data.layout1-tile2', ...)]

If we now look up the tile again, we will get the new value:

    >>> tile = traversable.traverse(u'layout1-tile2', ['sample.persistenttile'])
    >>> tile()
    u'<b>You said</b> Hello!'

We can also remove the annotation using the data manager:

    >>> dm.delete()
    >>> sorted(dict(context.__annotations__).items()) # doctest: +ELLIPSIS
    []

Tile URLs
---------

As we have seen, tiles have a canonical URL. For transient tiles, this may
also encode some tile data.

If you have a tile instance and you need to know the canonical tile URL,
you can use the `IAbsoluteURL` API.

For the purposes of testing, we need to ensure that we can get an absolute URL
for the context. We'll achieve that with a dummy adapter:

    >>> from zope.interface import implements
    >>> from zope.component import adapts

    >>> from zope.traversing.browser.interfaces import IAbsoluteURL
    >>> from zope.publisher.interfaces.http import IHTTPRequest

    >>> class DummyAbsoluteURL(object):
    ...     implements(IAbsoluteURL)
    ...     adapts(IContext, IHTTPRequest)
    ...     
    ...     def __init__(self, context, request):
    ...         self.context = context
    ...         self.request = request
    ...     
    ...     def __unicode__(self):
    ...         return u"http://example.com/context"
    ...     def __str__(self):
    ...         return u"http://example.com/context"
    ...     def __call__(self):
    ...         return self.__str__()
    ...     def breadcrumbs(self):
    ...         return ({'name': u'context', 'url': 'http://example.com/context'},)
    >>> provideAdapter(DummyAbsoluteURL, name=u"absolute_url")
    >>> provideAdapter(DummyAbsoluteURL)
    
    >>> from zope.traversing.browser.absoluteurl import absoluteURL
    >>> from zope.component import getMultiAdapter

    >>> context = Context()
    >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'css_class': u'foo'})
    >>> traversable = getMultiAdapter((context, request), ITraversable, name=u"tile")
    >>> transientTile = traversable.traverse(u'layout1-tile1', ['sample.tile'])

    >>> absoluteURL(transientTile, request)
    'http://example.com/context/++tile++layout1-tile1/sample.tile?title=My+title&css_class=foo&count%3Along=5'
    
    >>> getMultiAdapter((transientTile, request), IAbsoluteURL).breadcrumbs() == \
    ...     ({'url': 'http://example.com/context', 'name': u'context'},
    ...      {'url': 'http://example.com/context/++tile++layout1-tile1/sample.tile', 'name': u'layout1-tile1'})
    True
    
For persistent tiles, the are no data parameters:

    >>> context = Context()
    >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'css_class': u'foo'})
    >>> traversable = getMultiAdapter((context, request), ITraversable, name=u"tile")
    >>> persistentTile = traversable.traverse(u'layout1-tile2', ['sample.persistenttile'])

    >>> absoluteURL(persistentTile, request)
    'http://example.com/context/++tile++layout1-tile2/sample.persistenttile'
    
    >>> getMultiAdapter((persistentTile, request), IAbsoluteURL).breadcrumbs() == \
    ...     ({'url': 'http://example.com/context', 'name': u'context'},
    ...      {'url': 'http://example.com/context/++tile++layout1-tile2/sample.persistenttile', 'name': u'layout1-tile2'})
    True
    
Add view traverser
------------------

As mentioned, this package does not provide UI support for tiles, but it does
provide a traverser which can be used to write edit views.

A tile edit view requires three pieces of information: the context and
request, as usual, and the tile type. The add view traverser thus allows the
add view to be registered as a multi-adapter on these three discriminators.

To illustrate this, let's register a generic add view, which can operate on
any tile type.

    >>> from zope.interface import Interface, implements
    >>> from zope.component import adapts
    >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer

    >>> from plone.tiles.interfaces import ITileAddView, ITileType

    >>> class DefaultAddView(object):
    ...     implements(ITileAddView)
    ...     adapts(Interface, IDefaultBrowserLayer, ITileType)
    ...     
    ...     def __init__(self, context, request, tileType):
    ...         self.context = context
    ...         self.request = request
    ...         self.tileType = tileType
    ...     
    ...     def __call__(self):
    ...         return "Adding %s" % self.tileType

    >>> from zope.component import provideAdapter
    >>> provideAdapter(DefaultAddView)

The tile add view traverser is called `++addtile++`, and can normally be
invoked with a URL like::

    http://example.com/site/obj/++addtile++my.tile

Here, my.tile is the name of the tile type. We will simulate this now, using
our sample tile from above.

    >>> context = Context()
    >>> request = TestRequest()

    >>> traversable = getMultiAdapter((context, request), ITraversable, name=u"addtile")
    >>> addview = traversable.traverse(u'sample.tile', [])

The add view returned should be an instance of our generic add view, which
was registered as an unnamed adapter providing `ITileAddView`:

    >>> isinstance(addview, DefaultAddView)
    True
    >>> addview.tileType is sample_tile_type
    True
    >>> addview.__name__
    u'sample.tile'
    >>> addview.__parent__ is context
    True

This works well for a default add view, but sometimes we will want a more
specific add view for a particular type of tile. One way to do that would
be to have a more-specific interface than the generic `ITileType` for this
type of tile. However, that would be cumbersome, especially since tiles are
normally registered with a ZCML directive that configures the tile type object
automatically. Instead, we can register a *named* multi-adapter, where the
name matches the tile name:

    >>> class SpecificAddView(object):
    ...     implements(ITileAddView)
    ...     adapts(Interface, IDefaultBrowserLayer, ITileType)
    ...     
    ...     def __init__(self, context, request, tileType):
    ...         self.context = context
    ...         self.request = request
    ...         self.tileType = tileType
    ...     
    ...     def __call__(self):
    ...         return "Adding specific %s" % self.tileType

    >>> provideAdapter(SpecificAddView, name=u"sample.tile")

We can now try traversal again:

    >>> traversable = getMultiAdapter((context, request), ITraversable, name=u"addtile")
    >>> addview = traversable.traverse(u'sample.tile', [])

    >>> isinstance(addview, SpecificAddView)
    True
